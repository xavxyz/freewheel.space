<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="shortcut icon"
      type="image/x-icon"
      href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAARNJREFUWEftlVsOgjAQRTuuDBagMQHcjrgdgcTgAmBl1vCBFpx2HhT5gU8IcO6ZuQBm4wM2fr/ZAdQG8vycgH11wwirplU/R31jkR07YyAZAADM7V63pWafVABu+vGlWggVgJveTa0ZhRjgkp9Ka80V062xIAYospMNzVpqQQTgU+8CSS2wAbDF85mwcEjr+tFzWsEG4KTXNIIFIEkvhWABSNJLa0kChGpHzZizkEEAjfo5FFXLIIBWvaSWXoAY6TkL6QWIkf5rwvZV80zRzzd2MmZ6ygJqgPreU9vvu44t5A/AktpRYFgtJwBrqKdqOQGIu3i4j7mFD8A/0o9I7t9yYmDN+fsqSf4LqMVaen0H2A28AZ7RiiF7SWcqAAAAAElFTkSuQmCC"
    />
    <title>pyramid.space</title>
    <style>
      body {
        margin: 0;
        display: flex;
        height: 100vh;
        justify-content: center;
        align-items: center;
        overflow: hidden;
      }

      #particles {
        position: fixed;
        width: 100%;
        height: 100%;
        background-color: rgb(49, 49, 49);
        background-size: cover;
        background-repeat: no-repeat;
        background-position: 50% 50%;
        top: 0;
        left: 0;
        z-index: 0;
      }

      #pyramid {
        border-radius: 8px;
        z-index: 1;
      }

      #pyramid.appear-in {
        opacity: 0;
        transform-origin: 50% 50%;
        transition: opacity 1.2s ease-out;
      }
    </style>
  </head>
  <body>
    <div id="particles"></div>
    <script src="particles.min.js"></script>
    <canvas id="pyramid" width="300" height="300"></canvas>
    <script>
      particlesJS.load("particles", "particles.json", function () {
        const pyramidCanvas = document.querySelector("#pyramid");

        setTimeout(() => {
          pyramidCanvas.style.opacity = 1;
        }, 1000);
      });
    </script>
    <script>
      const Point3d = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      };

      // set up the canvas and context
      const canvas = document.querySelector("#pyramid");
      const ctx = canvas.getContext("2d");

      // dimensions
      const h = canvas.height;
      const w = canvas.width;

      ctx.fillStyle = "#eee";
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 8;
      ctx.lineCap = "round";

      const cx = w / 2;
      const cy = h / 2;
      const cz = 0;
      const size = h / 4;

      const vertices = [
        // 前右
        new Point3d(cx + size, cy + size, cz - size),
        // 前左
        new Point3d(cx - size, cy + size, cz - size),
        // 后右
        new Point3d(cx + size, cy + size, cz + size),
        // 后左
        new Point3d(cx - size, cy + size, cz + size),
        // 枢心
        new Point3d(cx, cy, cz),
      ];

      const edges = [
        [0, 1],
        [1, 3],
        [2, 0],
        [3, 2],
        // -
        [0, 4],
        [1, 4],
        [2, 4],
        [3, 4],
      ];

      // ~= 5 seconds for a turn in the trigonometric sense
      const baseSpeed = -(2 * Math.PI) / 300;
      const center = { x: cx, y: cy, z: cz };

      /*
      // Simplicity
      function spinZ() {
        for (let v of vertices) {
          let dx = v.x - cx;
          let dy = v.y - cy;
          let x = dx * Math.cos(angle) - dy * Math.sin(angle);
          let y = dx * Math.sin(angle) + dy * Math.cos(angle);
          v.x = x + cx;
          v.y = y + cy;
        }
      }
      */

      // ? Complexifun
      function spinAround(rotationAxis, angle = baseSpeed, ref = center) {
        const offsets = ["x", "y", "z"].filter((axis) => axis !== rotationAxis);
        const [horizontal, vertical] = offsets;

        for (let vertex of vertices) {
          // Change reference
          const deltas = offsets.map((axis) => vertex[axis] - ref[axis]);
          const [horizontalDelta, verticalDelta] = deltas;

          // Compute new coords
          const newCoords = {
            [horizontal]:
              horizontalDelta * Math.cos(angle) -
              verticalDelta * Math.sin(angle),
            [vertical]:
              horizontalDelta * Math.sin(angle) +
              verticalDelta * Math.cos(angle),
          };

          // Switch back to the canvas as reference
          offsets.forEach((axis) => {
            vertex[axis] = newCoords[axis] + ref[axis];
          });
        }
      }

      let frame = 0;
      function eternalReturn() {
        frame++;

        // background
        ctx.fillRect(0, 0, w, h);

        // Demo one basic turn around
        if (frame <= 300) {
          spinAround("y", baseSpeed);
        }

        // draw each edge
        for (let edge of edges) {
          ctx.beginPath();
          ctx.moveTo(vertices[edge[0]].x, vertices[edge[0]].y);
          ctx.lineTo(vertices[edge[1]].x, vertices[edge[1]].y);
          ctx.stroke();
        }

        // call the next frame
        requestAnimationFrame(eternalReturn);
      }

      requestAnimationFrame(eternalReturn);
    </script>
  </body>
</html>
